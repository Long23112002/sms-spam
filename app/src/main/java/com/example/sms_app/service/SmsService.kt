package com.example.sms_app.service

import android.annotation.SuppressLint
import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.app.Service
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.os.Build
import android.os.IBinder
import android.telephony.SmsManager
import android.telephony.TelephonyManager
import android.util.Log
import androidx.annotation.RequiresApi
import androidx.core.app.NotificationCompat
import kotlinx.coroutines.suspendCancellableCoroutine
import kotlin.coroutines.resume
import com.example.sms_app.R
import com.example.sms_app.data.Customer
import com.example.sms_app.data.SmsRepository
import com.example.sms_app.data.AppSettings
import com.example.sms_app.data.SessionBackup
import com.example.sms_app.data.SmsSession
import kotlinx.coroutines.*
import kotlinx.coroutines.TimeoutCancellationException
import kotlin.random.Random
import com.example.sms_app.MainActivity
import com.example.sms_app.data.SmsTemplate
import com.example.sms_app.utils.SmsUtils
import android.os.Handler
import android.os.Looper
import android.app.Activity

class SmsService : Service() {
    private var serviceJob: Job? = null
    private lateinit var smsRepository: SmsRepository
    private lateinit var sessionBackup: SessionBackup
    private var selectedTemplateId: Int = 1
    private var shouldStop = false
    private lateinit var smsResultReceiver: BroadcastReceiver
    private lateinit var smsDeliveryReceiver: BroadcastReceiver
    private val pendingSmsResults = mutableMapOf<String, kotlinx.coroutines.CancellableContinuation<Boolean>>()
    private val multipartMessageTracker = mutableMapOf<String, MutableSet<String>>() // Track parts of multipart messages
    private val pendingSmsDeliveries = mutableMapOf<String, Customer>()
    private var isRunning = false
    private var totalSent = 0
    private var totalToSend = 0
    private var currentTemplateId = 0
    private var intervalSeconds = 0
    private var maxRetryAttempts = 0
    private var retryDelaySeconds = 0
    private var isSendingMessages = false
    private var currentProgress = 0
    private var totalMessageCount = 0
    private val serviceScope = CoroutineScope(Dispatchers.IO)
    private val TAG = "SmsService"
    
    companion object {
        const val NOTIFICATION_ID = 1
        const val CHANNEL_ID = "SmsServiceChannel"
        const val NOTIFICATION_CHANNEL_ID = "SmsServiceChannel"
        
        const val ACTION_PROGRESS_UPDATE = "com.example.sms_app.ACTION_PROGRESS_UPDATE"
        const val ACTION_SMS_COMPLETED = "com.example.sms_app.ACTION_SMS_COMPLETED"
        const val ACTION_CUSTOMER_DELETED = "com.example.sms_app.ACTION_CUSTOMER_DELETED"
        
        const val EXTRA_PROGRESS = "progress"
        const val EXTRA_TOTAL = "total"
        const val EXTRA_MESSAGE = "message"
        const val EXTRA_CUSTOMER_ID = "customer_id"
        const val EXTRA_TEMPLATE_ID = "template_id"
        const val EXTRA_INTERVAL_SECONDS = "interval_seconds"
        const val EXTRA_MAX_RETRY = "max_retry"
        const val EXTRA_RETRY_DELAY = "retry_delay"
        
        // SMS Delivery constants
        const val SMS_SENT_ACTION = "com.example.sms_app.SMS_SENT"
        const val SMS_DELIVERED_ACTION = "com.example.sms_app.SMS_DELIVERED"
        const val SMS_TIMEOUT_MS = 30000L // 30 seconds timeout
        
        // Danh s√°ch emoji ng·∫´u nhi√™n ƒë·ªÉ th√™m v√†o tin nh·∫Øn
        private val RANDOM_EMOJIS = listOf(
            "üëç", "üëã", "üòä", "üôÇ", "üëå", "‚úÖ", "üéâ", "‚ú®", "üíØ", "‚≠ê",
            "üåü", "üí´", "üåà", "üîÜ", "üì≤", "‚úîÔ∏è", "üí™", "ü§ù", "üëè", "üôå"
        )
        
        // Danh s√°ch k√Ω t·ª± ƒë·∫∑c bi·ªát ƒë·ªÉ th√™m v√†o tin nh·∫Øn
        private val RANDOM_CHARS = listOf(
            " ", "  ", " ¬∑ ", ".", "..", "‚Ä¶", " ", " ", " ", "  ",
            " ", " ", "", " ", " ", " ", " ", " ", " ", " "
        )
        
        // Danh s√°ch t·ª´ ng·∫´u nhi√™n ƒë·ªÉ th√™m v√†o tin nh·∫Øn
        private val RANDOM_WORDS = listOf(
            "Xin", "C·∫£m ∆°n", "Ch√∫c", "Th√¢n", "Tr√¢n tr·ªçng", "M·∫øn", "Hi", "Vui", "T·ªët", "Th√¢n m·∫øn"
        )
    }
    
    override fun onCreate() {
        super.onCreate()
        Log.d(TAG, "SmsService onCreate")
        isSendingMessages = false
        currentProgress = 0
        totalMessageCount = 0
        
        smsRepository = SmsRepository(applicationContext)
        sessionBackup = SessionBackup(this)
        
        // T·∫°o notification channel cho Android 8.0 tr·ªü l√™n
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(
                NOTIFICATION_CHANNEL_ID,
                "SMS Service Channel",
                NotificationManager.IMPORTANCE_HIGH
            ).apply {
                description = "Channel for SMS sending service notifications"
                setShowBadge(false)
            }
            
            val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
            notificationManager.createNotificationChannel(channel)
        }
        
        // Initialize SmsUtils for standard SMS functionality
        SmsUtils.initialize()
        
        // Skip dynamic code loading for now as it's causing issues
        Log.d(TAG, "Using standard SMS APIs instead of dynamic loading")
        
        try {
            setupSmsResultReceiver()
            setupSmsDeliveryReceiver()
        } catch (e: Exception) {
            Log.e(TAG, "Failed to setup SMS result receiver", e)
        }
        
        // Ki·ªÉm tra c√°c c√†i ƒë·∫∑t thi·∫øt b·ªã
        val deviceStatus = checkDeviceSettings()
        Log.d(TAG, "Device status: $deviceStatus")
    }
    
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        Log.d(TAG, "üöÄ SmsService onStartCommand called, intent: ${intent?.action}")
        
        try {
            if (intent != null) {
                try {
                    // Ki·ªÉm tra xem c√≥ ph·∫£i l√† action d·ª´ng d·ªãch v·ª• kh√¥ng
                    if (intent.action == "STOP_SMS_SERVICE") {
                        Log.d(TAG, "Received stop action from notification")
                        isRunning = false
                        sendCompletionBroadcast("D·ªãch v·ª• g·ª≠i SMS ƒë√£ b·ªã d·ª´ng b·ªüi ng∆∞·ªùi d√πng")
                        stopSelf()
                        return START_NOT_STICKY
                    }
                    
                    currentTemplateId = intent.getIntExtra(EXTRA_TEMPLATE_ID, 1)
                    intervalSeconds = intent.getIntExtra(EXTRA_INTERVAL_SECONDS, 25)
                    maxRetryAttempts = intent.getIntExtra(EXTRA_MAX_RETRY, 3)
                    retryDelaySeconds = intent.getIntExtra(EXTRA_RETRY_DELAY, 10)
                    
                    Log.d(TAG, "üìã Loaded settings: templateId=$currentTemplateId, interval=$intervalSeconds, maxRetry=$maxRetryAttempts, retryDelay=$retryDelaySeconds")
                    
                    // Kh·ªüi t·∫°o notification v·ªõi m·ª©c ƒë·ªô ∆∞u ti√™n cao h∆°n
                    try {
                        val notification = createNotification("ƒêang chu·∫©n b·ªã g·ª≠i SMS...")
                        Log.d(TAG, "üì≤ Starting foreground service with notification")
                        startForeground(NOTIFICATION_ID, notification)
                    } catch (e: Exception) {
                        Log.e(TAG, "‚ùå Error creating notification", e)
                    }
                    
                    // Th√™m m·ªôt delay nh·ªè tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu ƒë·ªÉ ƒë·∫£m b·∫£o foreground service ƒë√£ ƒë∆∞·ª£c thi·∫øt l·∫≠p
                    serviceScope.launch {
                        try {
                            delay(500) // ƒê·ª£i 500ms
                            Log.d(TAG, "‚è±Ô∏è Starting SMS sending after delay")
                            startSendingSms()
                        } catch (e: Exception) {
                            Log.e(TAG, "‚ùå Error in delayed start", e)
                            sendCompletionBroadcast("L·ªói kh·ªüi ƒë·ªông d·ªãch v·ª•: ${e.message}")
                            stopSelf()
                        }
                    }
                } catch (e: Exception) {
                    Log.e(TAG, "‚ùå Error processing intent", e)
                    sendCompletionBroadcast("L·ªói x·ª≠ l√Ω intent: ${e.message}")
                    stopSelf()
                    return START_NOT_STICKY
                }
            } else {
                Log.w(TAG, "‚ö†Ô∏è onStartCommand called with null intent")
                stopSelf()
                return START_NOT_STICKY
            }
        } catch (e: Exception) {
            Log.e(TAG, "üí• Critical error in onStartCommand", e)
            try {
                sendCompletionBroadcast("L·ªói nghi√™m tr·ªçng: ${e.message}")
            } catch (e2: Exception) {
                Log.e(TAG, "Failed to send completion broadcast", e2)
            }
            stopSelf()
            return START_NOT_STICKY
        }
        
        // S·ª≠ d·ª•ng START_REDELIVER_INTENT thay v√¨ START_NOT_STICKY ƒë·ªÉ h·ªá th·ªëng kh·ªüi ƒë·ªông l·∫°i service n·∫øu b·ªã kill
        return START_REDELIVER_INTENT
    }
    
    override fun onDestroy() {
        super.onDestroy()
        Log.d(TAG, "onDestroy called, ensuring completion broadcast is sent")
        
        // ƒê·∫£m b·∫£o g·ª≠i th√¥ng b√°o ho√†n th√†nh khi service b·ªã d·ª´ng
        try {
            // Lu√¥n g·ª≠i th√¥ng b√°o ho√†n th√†nh khi service b·ªã d·ª´ng
            val message = if (totalSent > 0) {
                "üèÅ ƒê√£ g·ª≠i $totalSent/${totalToSend} tin nh·∫Øn (d·ªãch v·ª• ƒë√£ k·∫øt th√∫c)"
            } else {
                "‚ö†Ô∏è D·ªãch v·ª• g·ª≠i SMS ƒë√£ d·ª´ng"
            }
            sendCompletionBroadcast(message)
            
            // C·∫≠p nh·∫≠t session backup
            sessionBackup.updateSessionTime()
        } catch (e: Exception) {
            Log.e(TAG, "Error sending completion broadcast in onDestroy", e)
        }
        
        // H·ªßy c√°c t√°c v·ª• ƒëang ch·∫°y
        serviceJob?.cancel()
        smsResultReceiver?.let { unregisterReceiver(it) }
        smsDeliveryReceiver?.let { unregisterReceiver(it) }
        pendingSmsResults.values.forEach { it.cancel() }
        pendingSmsResults.clear()
        pendingSmsDeliveries.clear()
        multipartMessageTracker.clear()
        isRunning = false
    }
    
    override fun onBind(intent: Intent?): IBinder? = null
    
    private fun startSendingSms() {
        try {
            if (isRunning) return
            isRunning = true

            // Ki·ªÉm tra c√†i ƒë·∫∑t thi·∫øt b·ªã tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu
            val deviceCheck = checkDeviceSettings()
            Log.i(TAG, "üîç Device check result: $deviceCheck")

            if (deviceCheck.contains("‚ùå")) {
                Log.e(TAG, "‚ùå Device check failed, stopping service")
                sendCompletionBroadcast("L·ªói thi·∫øt b·ªã: $deviceCheck")
                stopSelf()
                return
            }

            val customers = smsRepository.getCustomers().filter { it.isSelected }
            
            // Debug logs to check what's being loaded
            val allTemplates = smsRepository.getTemplates()
            val messageTemplates = smsRepository.getMessageTemplates()
            Log.d(TAG, "üìã Loaded ${allTemplates.size} templates: ${allTemplates.map { it.id }}")
            Log.d(TAG, "üìã Loaded ${messageTemplates.size} message templates: ${messageTemplates.map { it.id }}")
            Log.d(TAG, "üî¢ Current template ID: $currentTemplateId")
            
            // Check both template sources
            var template = smsRepository.getTemplates().find { it.id == currentTemplateId.toString() }
            
            // If template not found, try to get from message templates and convert
            if (template == null) {
                val messageTemplate = smsRepository.getMessageTemplates().find { it.id == currentTemplateId }
                if (messageTemplate != null) {
                    template = SmsTemplate(
                        id = messageTemplate.id.toString(),
                        name = messageTemplate.description,
                        content = messageTemplate.content
                    )
                    Log.d(TAG, "üîÑ Using converted message template: ${template.name}")
                }
            }
            
            if (customers.isEmpty()) {
                Log.e(TAG, "‚ùå No customers selected for SMS")
                sendCompletionBroadcast("Kh√¥ng c√≥ kh√°ch h√†ng ƒë∆∞·ª£c ch·ªçn")
                stopSelf()
                return
            }
            
            if (template == null) {
                Log.e(TAG, "‚ùå Template ID $currentTemplateId not found")
                sendCompletionBroadcast("Kh√¥ng t√¨m th·∫•y template ID: $currentTemplateId")
                stopSelf()
                return
            }
            
            totalToSend = customers.size
            totalSent = 0

            Log.i(TAG, "üöÄ Starting SMS sending: $totalToSend messages to send")
            Log.d(TAG, "üìã Template: ${template.name} (ID: ${template.id})")
            Log.d(TAG, "üî§ Template content: ${template.content}")
            Log.d(TAG, "‚öôÔ∏è Settings: interval=${intervalSeconds}s, maxRetry=$maxRetryAttempts, retryDelay=${retryDelaySeconds}s")

            // L∆∞u tr·ªØ phi√™n l√†m vi·ªác hi·ªán t·∫°i
            val session = SmsSession(
                sessionId = sessionBackup.generateSessionId(),
                templateId = currentTemplateId,
                totalCustomers = customers.size,
                sentCount = 0,
                remainingCustomers = customers,
                startTime = System.currentTimeMillis(),
                lastUpdateTime = System.currentTimeMillis()
            )
            sessionBackup.saveActiveSession(session)
            
            // C·∫≠p nh·∫≠t notification ƒë·ªÉ tƒÉng m·ª©c ƒë·ªô ∆∞u ti√™n
            val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
            notificationManager.notify(NOTIFICATION_ID, createNotification("B·∫Øt ƒë·∫ßu g·ª≠i ${customers.size} tin nh·∫Øn..."))
            
            serviceScope.launch {
                try {
                    // Th√™m timeout cho to√†n b·ªô qu√° tr√¨nh g·ª≠i SMS (10 ph√∫t)
                    withTimeout(10 * 60 * 1000L) {
                        sendSmsToCustomers(customers, template.content)
                    }
                } catch (e: TimeoutCancellationException) {
                    Log.e(TAG, "‚è∞ SMS sending timeout after 10 minutes")
                    sendCompletionBroadcast("‚è∞ Timeout: Qu√° tr√¨nh g·ª≠i SMS b·ªã d·ª´ng sau 10 ph√∫t")
                    stopSelf()
                } catch (e: Exception) {
                    Log.e(TAG, "üí• Critical error in SMS sending", e)
                    sendCompletionBroadcast("üí• L·ªói nghi√™m tr·ªçng: ${e.message}")
                    stopSelf()
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error in startSendingSms", e)
            sendCompletionBroadcast("L·ªói b·∫Øt ƒë·∫ßu g·ª≠i SMS: ${e.message}")
            stopSelf()
        }
    }
    
    private suspend fun sendSmsToCustomers(customers: List<Customer>, templateContent: String) {
        try {
            // ƒê·∫£m b·∫£o service v·∫´n ch·∫°y trong foreground
            val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
            notificationManager.notify(NOTIFICATION_ID, createNotification("ƒêang g·ª≠i tin nh·∫Øn..."))
            
            // ƒê·∫øm s·ªë l·∫ßn th·ª≠ l·∫°i t·ªïng c·ªông
            var totalRetries = 0
            val maxTotalRetries = maxRetryAttempts * 3 // Gi·ªõi h·∫°n s·ªë l·∫ßn th·ª≠ l·∫°i t·ªïng c·ªông
            
            for (customer in customers) {
                if (!isRunning) {
                    Log.d(TAG, "Service stopped, breaking SMS sending loop")
                    break
                }
                
                try {
                    // C·∫≠p nh·∫≠t notification ƒë·ªÉ gi·ªØ service trong foreground
                    notificationManager.notify(
                        NOTIFICATION_ID, 
                        createNotification("ƒêang g·ª≠i tin nh·∫Øn ${totalSent + 1}/${totalToSend}")
                    )
                    
                    val message = formatMessage(templateContent, customer)
                    Log.d(TAG, "üöÄ Attempting to send SMS to ${customer.name} (${customer.phoneNumber})")
                    Log.d(TAG, "üìù Message content: ${message.take(50)}${if (message.length > 50) "..." else ""}")

                    // S·ª≠ d·ª•ng ph∆∞∆°ng th·ª©c g·ª≠i SMS v·ªõi delivery report ƒë·ªÉ c√≥ th·ªÉ theo d√µi tr·∫°ng th√°i
                    val selectedSim = smsRepository.getSelectedSim()
                    var success = false
                    var retryCount = 0
                    
                    while (!success && retryCount < maxRetryAttempts && totalRetries < maxTotalRetries && isRunning) {
                        try {
                            if (retryCount > 0) {
                                Log.d(TAG, "Retry attempt $retryCount for ${customer.phoneNumber}")
                                delay(retryDelaySeconds * 1000L)
                            }
                            
                            success = sendSmsWithDeliveryReport(customer.phoneNumber, message, selectedSim, customer)
                            
                            if (!success) {
                                retryCount++
                                totalRetries++
                                Log.d(TAG, "SMS sending failed, retry $retryCount/$maxRetryAttempts")
                            }
                        } catch (e: Exception) {
                            Log.e(TAG, "‚ùå Exception during SMS sending to ${customer.phoneNumber}: ${e.message}", e)
                            retryCount++
                            totalRetries++
                            
                            // ƒê·ª£i tr∆∞·ªõc khi th·ª≠ l·∫°i
                            delay(retryDelaySeconds * 1000L)
                        }
                    }
                    
                    if (success) {
                        totalSent++
                        // Kh√¥ng x√≥a kh√°ch h√†ng ngay, m√† ch·ªù x√°c nh·∫≠n t·ª´ delivery report
                        // Ch·ªâ ƒë√°nh d·∫•u l√† ƒë√£ g·ª≠i th√†nh c√¥ng
                        
                        // G·ª≠i broadcast c·∫≠p nh·∫≠t ti·∫øn ƒë·ªô
                        sendProgressBroadcast(
                            totalSent,
                            totalToSend,
                            "‚úÖ ƒê√£ g·ª≠i SMS cho ${customer.name} (${customer.phoneNumber}), ƒëang ch·ªù x√°c nh·∫≠n"
                        )

                        // TƒÉng s·ªë l∆∞·ª£ng SMS ƒë√£ g·ª≠i trong ng√†y
                        smsRepository.incrementSmsCount(selectedSim)

                        Log.d(TAG, "‚úÖ SMS sent successfully to ${customer.name} (${customer.phoneNumber})")

                        // ƒê·ª£i m·ªôt kho·∫£ng th·ªùi gian ng·∫´u nhi√™n tr∆∞·ªõc khi g·ª≠i tin nh·∫Øn ti·∫øp theo
                        val randomDelay = SmsUtils.getRandomDelay(intervalSeconds)
                        Log.d(TAG, "‚è≥ Waiting ${randomDelay}ms before next SMS...")
                        
                        // Chia nh·ªè th·ªùi gian ch·ªù ƒë·ªÉ ki·ªÉm tra tr·∫°ng th√°i service th∆∞·ªùng xuy√™n h∆°n
                        val checkInterval = 1000L // 1 gi√¢y
                        var remainingDelay = randomDelay
                        
                        while (remainingDelay > 0 && isRunning) {
                            val delayStep = minOf(checkInterval, remainingDelay)
                            delay(delayStep)
                            remainingDelay -= delayStep
                            
                            // C·∫≠p nh·∫≠t notification ƒë·ªÉ gi·ªØ service trong foreground - th∆∞·ªùng xuy√™n h∆°n
                            if (remainingDelay % 1000 == 0L) { // C·∫≠p nh·∫≠t m·ªói 1 gi√¢y
                                val remainingSecs = remainingDelay / 1000
                                val nextCustomerIndex = totalSent
                                
                                // T√≠nh t·ªïng th·ªùi gian c√≤n l·∫°i cho t·∫•t c·∫£ tin nh·∫Øn
                                val remainingCustomers = totalToSend - totalSent
                                val totalRemainingSeconds = remainingSecs + (remainingCustomers * intervalSeconds)
                                val totalRemainingMinutes = totalRemainingSeconds / 60
                                val totalRemainingSecsDisplay = totalRemainingSeconds % 60
                                
                                // Hi·ªÉn th·ªã th√¥ng tin chi ti·∫øt h∆°n trong notification
                                val notificationMessage = if (nextCustomerIndex < totalToSend) {
                                    val nextCustomer = customers[nextCustomerIndex]
                                    "ƒê√£ g·ª≠i $totalSent/$totalToSend tin nh·∫Øn. C√≤n l·∫°i: ${remainingSecs}s tr∆∞·ªõc khi g·ª≠i cho ${nextCustomer.name}"
                                } else {
                                    "ƒê√£ g·ª≠i $totalSent/$totalToSend tin nh·∫Øn. C√≤n l·∫°i: ${remainingSecs}s..."
                                }
                                
                                notificationManager.notify(
                                    NOTIFICATION_ID, 
                                    createNotification(notificationMessage)
                                )
                                
                                // C·∫≠p nh·∫≠t UI th√¥ng qua broadcast v·ªõi t·ªïng th·ªùi gian c√≤n l·∫°i
                                val progressMessage = if (nextCustomerIndex < totalToSend) {
                                    val nextCustomer = customers[nextCustomerIndex]
                                    if (remainingCustomers > 0) {
                                        "C√≤n l·∫°i: ${remainingSecs}s tr∆∞·ªõc khi g·ª≠i cho ${nextCustomer.name} (T·ªïng: ${totalRemainingMinutes}m:${totalRemainingSecsDisplay}s)"
                                    } else {
                                        "C√≤n l·∫°i: ${remainingSecs}s tr∆∞·ªõc khi g·ª≠i cho ${nextCustomer.name}"
                                    }
                                } else {
                                    "C√≤n l·∫°i: ${remainingSecs}s..."
                                }
                                
                                sendProgressBroadcast(
                                    totalSent,
                                    totalToSend,
                                    progressMessage
                                )
                            }
                        }
                    } else {
                        Log.e(TAG, "‚ùå Failed to send SMS to ${customer.name} (${customer.phoneNumber}) after $retryCount retries")
                        
                        // ƒê√°nh d·∫•u session th·∫•t b·∫°i ƒë·ªÉ c√≥ th·ªÉ kh√¥i ph·ª•c sau n√†y
                        sessionBackup.markSessionFailed(customer.id, "Kh√¥ng th·ªÉ g·ª≠i SMS sau $retryCount l·∫ßn th·ª≠")
                        
                        sendProgressBroadcast(
                            totalSent,
                            totalToSend,
                            "‚ùå L·ªói g·ª≠i ${customer.name} (${customer.phoneNumber}) sau $retryCount l·∫ßn th·ª≠"
                        )
                    }
                } catch (e: Exception) {
                    Log.e(TAG, "üí• Error processing customer ${customer.name} (${customer.phoneNumber})", e)
                    
                    // ƒê√°nh d·∫•u session th·∫•t b·∫°i ƒë·ªÉ c√≥ th·ªÉ kh√¥i ph·ª•c sau n√†y
                    sessionBackup.markSessionFailed(customer.id, "L·ªói x·ª≠ l√Ω: ${e.message}")
                    
                    sendProgressBroadcast(
                        totalSent,
                        totalToSend,
                        "üí• L·ªói x·ª≠ l√Ω ${customer.name}: ${e.message}"
                    )
                    
                    // ƒê·ª£i m·ªôt kho·∫£ng th·ªùi gian tr∆∞·ªõc khi x·ª≠ l√Ω kh√°ch h√†ng ti·∫øp theo
                    delay(5000)
                }
                
                // C·∫≠p nh·∫≠t th·ªùi gian ho·∫°t ƒë·ªông c·ªßa session
                sessionBackup.updateSessionTime()
            }

            // Ho√†n th√†nh g·ª≠i SMS
            Log.i(TAG, "üèÅ SMS sending completed: $totalSent/$totalToSend messages sent")
            sendCompletionBroadcast("üèÅ ƒê√£ ho√†n th√†nh g·ª≠i $totalSent/${totalToSend} tin nh·∫Øn")
            sessionBackup.completeSession()
            
            // Kh√¥ng d·ª´ng service ngay l·∫≠p t·ª©c ƒë·ªÉ cho ph√©p MainActivity nh·∫≠n ƒë∆∞·ª£c th√¥ng b√°o ho√†n th√†nh
            // v√† t·ª± quy·∫øt ƒë·ªãnh khi n√†o t·∫Øt UI loading
            Handler(Looper.getMainLooper()).postDelayed({
                Log.d(TAG, "D·ª´ng service sau khi ƒë√£ g·ª≠i th√¥ng b√°o ho√†n th√†nh")
                stopSelf()
            }, 1000) // ƒê·ª£i 1 gi√¢y ƒë·ªÉ ƒë·∫£m b·∫£o th√¥ng b√°o ƒë∆∞·ª£c g·ª≠i ƒëi
        } catch (e: Exception) {
            Log.e(TAG, "üí• Critical error in sendSmsToCustomers", e)
            sendCompletionBroadcast("üí• L·ªói nghi√™m tr·ªçng: ${e.message}")
            sessionBackup.updateSessionTime() // C·∫≠p nh·∫≠t th·ªùi gian ƒë·ªÉ c√≥ th·ªÉ kh√¥i ph·ª•c
            stopSelf()
        }
    }
    
    private suspend fun sendSmsWithDeliveryReport(
        phoneNumber: String,
        message: String,
        selectedSim: Int,
        customer: Customer
    ): Boolean = suspendCancellableCoroutine { continuation ->
        try {
            val requestId = "SMS_${System.currentTimeMillis()}_${phoneNumber.hashCode()}"
            
            // Store continuation for callback
            pendingSmsResults[requestId] = continuation
            
            // Store customer for delivery report
            pendingSmsDeliveries[requestId] = customer
            
            // Create PendingIntent for sent status
            val sentIntent = Intent(SMS_SENT_ACTION).apply {
                putExtra("REQUEST_ID", requestId)
                putExtra("CUSTOMER_ID", customer.id)
            }
            
            // Create PendingIntent for delivery status
            val deliveredIntent = Intent(SMS_DELIVERED_ACTION).apply {
                putExtra("REQUEST_ID", requestId)
                putExtra("CUSTOMER_ID", customer.id)
            }
            
            // Use compatible PendingIntent flags based on Android version
            val pendingIntentFlags = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_MUTABLE
            } else {
                PendingIntent.FLAG_UPDATE_CURRENT
            }
            
            val sentPendingIntent = PendingIntent.getBroadcast(
                this@SmsService, 
                requestId.hashCode(), 
                sentIntent, 
                pendingIntentFlags
            )
            
            val deliveredPendingIntent = PendingIntent.getBroadcast(
                this@SmsService,
                (requestId + "_DELIVERED").hashCode(),
                deliveredIntent,
                pendingIntentFlags
            )
            
            // Get appropriate SmsManager instance
            val smsManager = try {
                if (selectedSim != -1 && android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP_MR1) {
                    SmsManager.getSmsManagerForSubscriptionId(selectedSim)
                } else {
                    SmsManager.getDefault()
                }
            } catch (e: Exception) {
                Log.e(TAG, "‚ùå Error getting SmsManager for SIM $selectedSim, using default", e)
                SmsManager.getDefault()
            }
            
            // Check if message is longer than single SMS limit
            if (message.length > 160) {
                Log.d(TAG, "üìù Message longer than 160 chars, using divideMessage")
                val parts = smsManager.divideMessage(message)
                val sentIntents = ArrayList<PendingIntent>()
                
                // Create separate pending intents for each part
                for (i in parts.indices) {
                    val partRequestId = "${requestId}_PART_$i"
                    val partIntent = Intent(SMS_SENT_ACTION).apply {
                        putExtra("REQUEST_ID", requestId) // Use same request ID for all parts
                        putExtra("PART_ID", partRequestId) // Also include the part ID for tracking
                        putExtra("TOTAL_PARTS", parts.size)
                        putExtra("PART_INDEX", i)
                    }
                    val partPendingIntent = PendingIntent.getBroadcast(
                        this@SmsService,
                        partRequestId.hashCode(),
                        partIntent,
                        pendingIntentFlags
                    )
                    sentIntents.add(partPendingIntent)
                }
                
                // Initialize tracking for this multipart message
                multipartMessageTracker[requestId] = mutableSetOf()
                
                try {
                    // Send multi-part message
                    // T·∫°o danh s√°ch deliveredIntents
                    val deliveredIntents = ArrayList<PendingIntent>()
                    for (i in parts.indices) {
                        val deliveredPartRequestId = "${requestId}_DELIVERED_PART_$i"
                        val deliveredPartIntent = Intent(SMS_DELIVERED_ACTION).apply {
                            putExtra("REQUEST_ID", requestId)
                            putExtra("CUSTOMER_ID", customer.id)
                            putExtra("PART_ID", deliveredPartRequestId)
                            putExtra("TOTAL_PARTS", parts.size)
                            putExtra("PART_INDEX", i)
                        }
                        val deliveredPartPendingIntent = PendingIntent.getBroadcast(
                            this@SmsService,
                            deliveredPartRequestId.hashCode(),
                            deliveredPartIntent,
                            pendingIntentFlags
                        )
                        deliveredIntents.add(deliveredPartPendingIntent)
                    }
                    
                    smsManager.sendMultipartTextMessage(
                        phoneNumber,
                        null,
                        parts,
                        sentIntents,
                        deliveredIntents
                    )
                    Log.d(TAG, "üì§ Sending multi-part SMS (${parts.size} parts) to $phoneNumber (requestId: $requestId)")
                } catch (e: Exception) {
                    // If sendMultipartTextMessage fails, try normal send as fallback
                    Log.e(TAG, "‚ùå Error with sendMultipartTextMessage, falling back to sendTextMessage", e)
                    smsManager.sendTextMessage(
                        phoneNumber,
                        null,
                        message.take(160), // Take only first 160 chars in fallback mode
                        sentPendingIntent,
                        deliveredPendingIntent
                    )
                }
            } else {
                // Send normal SMS
                try {
                    smsManager.sendTextMessage(
                        phoneNumber,
                        null,
                        message,
                        sentPendingIntent,
                        deliveredPendingIntent
                    )
                    Log.d(TAG, "üì§ Sending SMS to $phoneNumber (requestId: $requestId)")
                } catch (e: Exception) {
                    Log.e(TAG, "‚ùå Exception in sendTextMessage: ${e.message}", e)
                    throw e // Re-throw to be caught by outer catch block
                }
            }
            
            // Set up timeout
            continuation.invokeOnCancellation {
                pendingSmsResults.remove(requestId)
                Log.w(TAG, "‚è∞ SMS timeout or cancelled (requestId: $requestId)")
            }
            
            // Timeout after 30 seconds
            CoroutineScope(Dispatchers.IO).launch {
                delay(SMS_TIMEOUT_MS)
                val timeoutContinuation = pendingSmsResults.remove(requestId)
                if (timeoutContinuation != null && timeoutContinuation == continuation) {
                    Log.e(TAG, "‚è∞ SMS timeout after ${SMS_TIMEOUT_MS}ms (requestId: $requestId)")
                    continuation.resume(false)
                }
            }
            
        } catch (e: Exception) {
            pendingSmsResults.remove(continuation.hashCode().toString())
            Log.e(TAG, "‚ùå Exception sending SMS: ${e.message}", e)
            continuation.resume(false)
        }
    }
    
    private fun formatMessage(template: String, customer: Customer): String {
        try {
            Log.d(TAG, "‚öôÔ∏è Formatting template: ${template.take(50)}${if (template.length > 50) "..." else ""}")
            Log.d(TAG, "üìã Customer data: ${customer.name}, ${customer.phoneNumber}, ${customer.idNumber}")
            
            // Format theo c√°c c·ªôt c·∫•u h√¨nh: xxx, yyy, sdt, ttt, zzz, www, uuu, vvv, rrr
            var message = template
            
            // C·ªôt 1: xxx - T√™n kh√°ch h√†ng
            message = message.replace("{xxx}", customer.name)
                .replace("{XXX}", customer.name)
                .replace(" xxx", " " + customer.name) // Th√™m space tr∆∞·ªõc ƒë·ªÉ tr√°nh thay th·∫ø t·ª´ trong t·ª´ kh√°c
                .replace(" XXX", " " + customer.name)
                .replace("xxx ", customer.name + " ")
                .replace("XXX ", customer.name + " ")
                .replace("\nxxx", "\n" + customer.name)
                .replace("\nXXX", "\n" + customer.name)
                // Tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát ·ªü ƒë·∫ßu ho·∫∑c cu·ªëi text
                .replace("xxx\n", customer.name + "\n")
                .replace("XXX\n", customer.name + "\n")
                
            // Ki·ªÉm tra tr∆∞·ªùng h·ª£p "xxx" ·ªü ƒë·∫ßu ho·∫∑c cu·ªëi chu·ªói
            if (message.startsWith("xxx")) {
                message = customer.name + message.substring(3)
            } 
            if (message.startsWith("XXX")) {
                message = customer.name + message.substring(3)
            }
            
            if (message.endsWith("xxx")) {
                message = message.substring(0, message.length - 3) + customer.name
            }
            if (message.endsWith("XXX")) {
                message = message.substring(0, message.length - 3) + customer.name
            }
            
            // X·ª≠ l√Ω c√°c tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát
            val specialCases = arrayOf(
                "Hello xxx", "Hello XXX", "Xin ch√†o xxx", "Xin ch√†o XXX",
                "Hi xxx", "Hi XXX", "Ch√†o xxx", "Ch√†o XXX"
            )
            
            for (case in specialCases) {
                if (message.contains(case)) {
                    val prefix = case.substring(0, case.length - 3)
                    message = message.replace(case, "$prefix${customer.name}")
                }
            }
            
            // C·ªôt 2: yyy - IdNumber (CMND)
            message = message.replace("{yyy}", customer.idNumber)
                .replace("{YYY}", customer.idNumber)
                .replace(" yyy", " " + customer.idNumber)
                .replace(" YYY", " " + customer.idNumber)
                .replace("yyy ", customer.idNumber + " ")
                .replace("YYY ", customer.idNumber + " ")
                .replace("\nyyy", "\n" + customer.idNumber)
                .replace("\nYYY", "\n" + customer.idNumber)
                // Tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát ·ªü ƒë·∫ßu ho·∫∑c cu·ªëi text
                .replace("yyy\n", customer.idNumber + "\n")
                .replace("YYY\n", customer.idNumber + "\n")
            
            // Ki·ªÉm tra tr∆∞·ªùng h·ª£p "yyy" ·ªü ƒë·∫ßu ho·∫∑c cu·ªëi chu·ªói
            if (message.startsWith("yyy")) {
                message = customer.idNumber + message.substring(3)
            }
            if (message.startsWith("YYY")) {
                message = customer.idNumber + message.substring(3)
            }
            
            if (message.endsWith("yyy")) {
                message = message.substring(0, message.length - 3) + customer.idNumber
            }
            if (message.endsWith("YYY")) {
                message = message.substring(0, message.length - 3) + customer.idNumber
            }
            
            // C·ªôt 3: sdt - S·ªë ƒëi·ªán tho·∫°i
            message = message.replace("{sdt}", customer.phoneNumber)
                .replace("{SDT}", customer.phoneNumber)
                .replace("{SƒêT}", customer.phoneNumber)
                .replace(" sdt", " " + customer.phoneNumber)
                .replace(" SDT", " " + customer.phoneNumber)
                .replace(" SƒêT", " " + customer.phoneNumber)
                .replace("sdt ", customer.phoneNumber + " ")
                .replace("SDT ", customer.phoneNumber + " ")
                .replace("SƒêT ", customer.phoneNumber + " ")
            
            // C·ªôt 4: ttt - ƒê·ªãa ch·ªâ
            message = message.replace("{ttt}", customer.address)
                .replace("{TTT}", customer.address)
                .replace(" ttt", " " + customer.address)
                .replace(" TTT", " " + customer.address)
                .replace("ttt ", customer.address + " ")
                .replace("TTT ", customer.address + " ")
            
            // C·ªôt 5-9: zzz, www, uuu, vvv, rrr - C√°c tr∆∞·ªùng t√πy ch·ªçn 1-5
            message = message.replace("{zzz}", customer.option1 ?: "")
                .replace("{ZZZ}", customer.option1 ?: "")
                .replace(" zzz", " " + (customer.option1 ?: ""))
                .replace(" ZZZ", " " + (customer.option1 ?: ""))
                .replace("zzz ", (customer.option1 ?: "") + " ")
                .replace("ZZZ ", (customer.option1 ?: "") + " ")
                
            message = message.replace("{www}", customer.option2 ?: "")
                .replace("{WWW}", customer.option2 ?: "")
                .replace(" www", " " + (customer.option2 ?: ""))
                .replace(" WWW", " " + (customer.option2 ?: ""))
                .replace("www ", (customer.option2 ?: "") + " ")
                .replace("WWW ", (customer.option2 ?: "") + " ")
                
            message = message.replace("{uuu}", customer.option3 ?: "")
                .replace("{UUU}", customer.option3 ?: "")
                .replace(" uuu", " " + (customer.option3 ?: ""))
                .replace(" UUU", " " + (customer.option3 ?: ""))
                .replace("uuu ", (customer.option3 ?: "") + " ")
                .replace("UUU ", (customer.option3 ?: "") + " ")
                
            message = message.replace("{vvv}", customer.option4 ?: "")
                .replace("{VVV}", customer.option4 ?: "")
                .replace(" vvv", " " + (customer.option4 ?: ""))
                .replace(" VVV", " " + (customer.option4 ?: ""))
                .replace("vvv ", (customer.option4 ?: "") + " ")
                .replace("VVV ", (customer.option4 ?: "") + " ")
                
            message = message.replace("{rrr}", customer.option5 ?: "")
                .replace("{RRR}", customer.option5 ?: "")
                .replace(" rrr", " " + (customer.option5 ?: ""))
                .replace(" RRR", " " + (customer.option5 ?: ""))
                .replace("rrr ", (customer.option5 ?: "") + " ")
                .replace("RRR ", (customer.option5 ?: "") + " ")
            
            // ƒê·ªìng th·ªùi v·∫´n gi·ªØ c√°ch thay th·∫ø bi·∫øn c≈© ƒë·ªÉ t∆∞∆°ng th√≠ch ng∆∞·ª£c
            message = message.replace("{ten}", customer.name)
                .replace("{TEN}", customer.name)
                .replace("{T√™n}", customer.name)
                .replace("{t√™n}", customer.name)
                
            message = message.replace("{cmnd}", customer.idNumber)
                .replace("{CMND}", customer.idNumber)
                .replace("{Cmnd}", customer.idNumber)
                
            message = message.replace("{diachi}", customer.address)
                .replace("{DIACHI}", customer.address)
                .replace("{Diachi}", customer.address)
                .replace("{ƒë·ªãa ch·ªâ}", customer.address)
                .replace("{ƒê·ªãa ch·ªâ}", customer.address)
                .replace("{ƒê·ªäA CH·ªà}", customer.address)
                
            message = message.replace("{option1}", customer.option1 ?: "")
                .replace("{OPTION1}", customer.option1 ?: "")
                
            message = message.replace("{option2}", customer.option2 ?: "")
                .replace("{OPTION2}", customer.option2 ?: "")
                
            message = message.replace("{option3}", customer.option3 ?: "")
                .replace("{OPTION3}", customer.option3 ?: "")
                
            message = message.replace("{option4}", customer.option4 ?: "")
                .replace("{OPTION4}", customer.option4 ?: "")
                
            message = message.replace("{option5}", customer.option5 ?: "")
                .replace("{OPTION5}", customer.option5 ?: "")
            
            // Th√™m th·ªùi gian hi·ªán t·∫°i n·∫øu c·∫ßn
            val currentDate = java.text.SimpleDateFormat("dd/MM/yyyy", java.util.Locale.getDefault()).format(java.util.Date())
            val currentTime = java.text.SimpleDateFormat("HH:mm", java.util.Locale.getDefault()).format(java.util.Date())
            
            message = message.replace("{ngay}", currentDate)
                .replace("{NGAY}", currentDate)
                .replace("{Ng√†y}", currentDate)
                .replace("{ng√†y}", currentDate)
                .replace("{gio}", currentTime)
                .replace("{GIO}", currentTime)
                .replace("{Gi·ªù}", currentTime)
                .replace("{gi·ªù}", currentTime)
            
            // Th√™m random emoji v√†o cu·ªëi tin nh·∫Øn n·∫øu tin nh·∫Øn c√≥ ƒë√°nh d·∫•u {emoji}
            if (message.contains("{emoji}")) {
                val emojis = listOf("üëã", "üëç", "‚úÖ", "üéâ", "üëå", "üòä", "üôÇ", "üíØ", "‚≠ê", "‚ú®")
                val randomEmoji = emojis.random()
                message = message.replace("{emoji}", randomEmoji)
            }
            
            Log.d(TAG, "‚úÖ Formatted result: ${message.take(50)}${if (message.length > 50) "..." else ""}")
            return message
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error formatting message: ${e.message}", e)
            return template // Return original template if formatting fails
        }
    }
    
    private fun createNotification(message: String): android.app.Notification {
        createNotificationChannel()
        
        val notificationIntent = Intent(this, MainActivity::class.java).apply {
            flags = Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_SINGLE_TOP
        }
        
        val pendingIntentFlags = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_UPDATE_CURRENT
        } else {
            PendingIntent.FLAG_UPDATE_CURRENT
        }
        
        val pendingIntent = PendingIntent.getActivity(
            this,
            0,
            notificationIntent,
            pendingIntentFlags
        )
        
        // Th√™m action d·ª´ng d·ªãch v·ª•
        val stopIntent = Intent(this, SmsService::class.java).apply {
            action = "STOP_SMS_SERVICE"
        }
        
        val stopPendingIntent = PendingIntent.getService(
            this,
            1,
            stopIntent,
            pendingIntentFlags
        )
        
        return NotificationCompat.Builder(this, CHANNEL_ID)
            .setContentTitle("D·ªãch v·ª• g·ª≠i SMS")
            .setContentText(message)
            .setSmallIcon(R.drawable.ic_sms_launcher)
            .setContentIntent(pendingIntent)
            .setPriority(NotificationCompat.PRIORITY_MAX) // M·ª©c ƒë·ªô ∆∞u ti√™n cao nh·∫•t
            .setCategory(NotificationCompat.CATEGORY_SERVICE) // ƒê√°nh d·∫•u l√† service notification
            .setOngoing(true) // Kh√¥ng cho ph√©p ng∆∞·ªùi d√πng x√≥a notification
            .setVisibility(NotificationCompat.VISIBILITY_PUBLIC) // Hi·ªÉn th·ªã tr√™n m√†n h√¨nh kh√≥a
            .addAction(android.R.drawable.ic_menu_close_clear_cancel, "D·ª´ng g·ª≠i", stopPendingIntent)
            .setForegroundServiceBehavior(NotificationCompat.FOREGROUND_SERVICE_IMMEDIATE) // Hi·ªÉn th·ªã ngay l·∫≠p t·ª©c
            .build()
    }
    
    private fun createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val name = "SMS Service Channel"
            val descriptionText = "Channel for SMS Service"
            val importance = NotificationManager.IMPORTANCE_HIGH // TƒÉng m·ª©c ƒë·ªô ∆∞u ti√™n
            val channel = NotificationChannel(CHANNEL_ID, name, importance).apply {
                description = descriptionText
                lockscreenVisibility = Notification.VISIBILITY_PUBLIC // Hi·ªÉn th·ªã tr√™n m√†n h√¨nh kh√≥a
                setShowBadge(true) // Hi·ªÉn th·ªã badge tr√™n icon
                enableLights(true) // B·∫≠t ƒë√®n th√¥ng b√°o
                lightColor = android.graphics.Color.BLUE
                enableVibration(true) // B·∫≠t rung
                vibrationPattern = longArrayOf(0, 1000, 500, 1000) // M·∫´u rung
            }
            
            val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
            notificationManager.createNotificationChannel(channel)
        }
    }
    
    private fun sendProgressBroadcast(progress: Int, total: Int, message: String) {
        val intent = Intent(ACTION_PROGRESS_UPDATE).apply {
            putExtra(EXTRA_PROGRESS, progress)
            putExtra(EXTRA_TOTAL, total)
            putExtra(EXTRA_MESSAGE, message)
        }
        sendBroadcast(intent)
        
        // C·∫≠p nh·∫≠t notification v·ªõi th√¥ng tin chi ti·∫øt h∆°n
        val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        
        // S·ª≠ d·ª•ng message ƒë√£ ƒë∆∞·ª£c ƒë·ªãnh d·∫°ng t·ª´ b√™n ngo√†i
        notificationManager.notify(NOTIFICATION_ID, createNotification(message))
    }
    
    private fun sendCompletionBroadcast(message: String) {
        try {
            Log.d(TAG, "üì£ Sending completion broadcast: $message")
            
            // T·∫°o intent v·ªõi th√¥ng tin
            val intent = Intent(ACTION_SMS_COMPLETED).apply {
                putExtra(EXTRA_MESSAGE, message)
                addFlags(Intent.FLAG_INCLUDE_STOPPED_PACKAGES)
            }
            
            // G·ª≠i broadcast tr√™n main thread ƒë·ªÉ ƒë·∫£m b·∫£o ƒë·ªô tin c·∫≠y
            Handler(Looper.getMainLooper()).post {
                try {
                    sendBroadcast(intent)
                    Log.d(TAG, "üì£ Sent completion broadcast on main thread")
                } catch (e: Exception) {
                    Log.e(TAG, "‚ùå Error sending completion broadcast on main thread", e)
                }
            }
            
            // Th√™m c∆° ch·∫ø th·ª≠ l·∫°i sau m·ªôt kho·∫£ng th·ªùi gian
            Handler(Looper.getMainLooper()).postDelayed({
                try {
                    applicationContext.sendBroadcast(intent)
                    Log.d(TAG, "üì£ Sent completion broadcast again after delay")
                } catch (e: Exception) {
                    Log.e(TAG, "‚ùå Error sending delayed completion broadcast", e)
                }
            }, 500) // Th·ª≠ l·∫°i sau 500ms
            
            // Th·ª≠ l·∫°i l·∫ßn th·ª© 3 v·ªõi context kh√°c
            Handler(Looper.getMainLooper()).postDelayed({
                try {
                    val newIntent = Intent(ACTION_SMS_COMPLETED).apply {
                        putExtra(EXTRA_MESSAGE, message)
                        addFlags(Intent.FLAG_INCLUDE_STOPPED_PACKAGES)
                        addFlags(Intent.FLAG_RECEIVER_FOREGROUND)
                    }
                    applicationContext.sendBroadcast(newIntent)
                    Log.d(TAG, "üì£ Sent completion broadcast third attempt")
                } catch (e: Exception) {
                    Log.e(TAG, "‚ùå Error sending third completion broadcast", e)
                }
            }, 1000) // Th·ª≠ l·∫°i sau 1 gi√¢y
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Critical error in sendCompletionBroadcast", e)
        }
    }
    
    @SuppressLint("UnspecifiedRegisterReceiverFlag")
    private fun setupSmsResultReceiver() {
        smsResultReceiver = object : BroadcastReceiver() {
            override fun onReceive(context: Context, intent: Intent) {
                val requestId = intent.getStringExtra("REQUEST_ID") ?: return
                val partId = intent.getStringExtra("PART_ID")
                val totalParts = intent.getIntExtra("TOTAL_PARTS", 0)
                val partIndex = intent.getIntExtra("PART_INDEX", -1)
                val continuation = pendingSmsResults[requestId]
                
                when (intent.action) {
                    SMS_SENT_ACTION -> {
                        // Ki·ªÉm tra k·∫øt qu·∫£ th·ª±c t·∫ø c·ªßa vi·ªác g·ª≠i SMS
                        val resultCode = resultCode
                        val success = when (resultCode) {
                            Activity.RESULT_OK -> {
                                Log.d(TAG, "‚úÖ SMS sent successfully (resultCode: RESULT_OK)")
                                true
                            }
                            SmsManager.RESULT_ERROR_GENERIC_FAILURE -> {
                                Log.e(TAG, "‚ùå SMS sending failed: Generic failure")
                                false
                            }
                            SmsManager.RESULT_ERROR_NO_SERVICE -> {
                                Log.e(TAG, "‚ùå SMS sending failed: No service")
                                false
                            }
                            SmsManager.RESULT_ERROR_NULL_PDU -> {
                                Log.e(TAG, "‚ùå SMS sending failed: Null PDU")
                                false
                            }
                            SmsManager.RESULT_ERROR_RADIO_OFF -> {
                                Log.e(TAG, "‚ùå SMS sending failed: Radio off")
                                false
                            }
                            else -> {
                                Log.w(TAG, "‚ö†Ô∏è SMS sending result unknown (resultCode: $resultCode), assuming success")
                                true // Gi·∫£ s·ª≠ th√†nh c√¥ng n·∫øu kh√¥ng r√µ k·∫øt qu·∫£
                            }
                        }
                        
                        // Log th√¥ng tin
                        if (partId != null) {
                            Log.d(TAG, "üì§ SMS part ${partIndex + 1}/$totalParts sent (requestId: $requestId, success: $success)")
                        } else {
                            Log.d(TAG, "üì§ SMS sent (requestId: $requestId, success: $success)")
                        }
                        
                        // X·ª≠ l√Ω tin nh·∫Øn nhi·ªÅu ph·∫ßn
                        if (partId != null && continuation != null) {
                            // Theo d√µi ph·∫ßn ƒë√£ ho√†n th√†nh
                            val tracker = multipartMessageTracker.getOrPut(requestId) { mutableSetOf() }
                            tracker.add(partId)
                            
                            // N·∫øu t·∫•t c·∫£ c√°c ph·∫ßn ƒë√£ ho√†n th√†nh, ti·∫øp t·ª•c coroutine
                            if (tracker.size == totalParts) {
                                pendingSmsResults.remove(requestId)?.resume(success)
                                multipartMessageTracker.remove(requestId)
                                Log.d(TAG, "‚úÖ All $totalParts parts of multipart SMS sent (requestId: $requestId, success: $success)")
                            }
                            return
                        }
                        
                        // SMS th√¥ng th∆∞·ªùng - x√≥a v√† ti·∫øp t·ª•c
                        pendingSmsResults.remove(requestId)?.resume(success)
                    }
                }
            }
        }
        
        val filter = IntentFilter().apply {
            addAction(SMS_SENT_ACTION)
        }
        
        try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                registerReceiver(smsResultReceiver, filter, Context.RECEIVER_NOT_EXPORTED)
            } else {
                registerReceiver(smsResultReceiver, filter)
            }
            Log.d(TAG, "‚úÖ SMS result receiver registered successfully")
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Failed to register SMS result receiver", e)
        }
    }
    
    @SuppressLint("UnspecifiedRegisterReceiverFlag")
    private fun setupSmsDeliveryReceiver() {
        smsDeliveryReceiver = object : BroadcastReceiver() {
            override fun onReceive(context: Context, intent: Intent) {
                val requestId = intent.getStringExtra("REQUEST_ID") ?: return
                val customerId = intent.getStringExtra("CUSTOMER_ID") ?: return
                
                when (intent.action) {
                    SMS_DELIVERED_ACTION -> {
                        val resultCode = resultCode
                        when (resultCode) {
                            Activity.RESULT_OK -> {
                                Log.d(TAG, "‚úÖ SMS delivered successfully (requestId: $requestId)")
                                
                                // L·∫•y th√¥ng tin kh√°ch h√†ng t·ª´ map
                                val customer = pendingSmsDeliveries.remove(requestId)
                                if (customer != null) {
                                    // X√≥a kh√°ch h√†ng sau khi SMS ƒë√£ ƒë∆∞·ª£c g·ª≠i ƒë·∫øn ng∆∞·ªùi nh·∫≠n
                                    deleteCustomerAfterSuccessfulSend(customer)
                                    
                                    // G·ª≠i broadcast c·∫≠p nh·∫≠t ti·∫øn ƒë·ªô
                                    sendProgressBroadcast(
                                        totalSent,
                                        totalToSend,
                                        "‚úÖ ƒê√£ x√°c nh·∫≠n g·ª≠i ƒë·∫øn ${customer.name} (${customer.phoneNumber})"
                                    )
                                } else {
                                    Log.w(TAG, "‚ö†Ô∏è Customer not found for requestId: $requestId")
                                }
                            }
                            Activity.RESULT_CANCELED -> {
                                Log.e(TAG, "‚ùå SMS delivery failed: Canceled (requestId: $requestId)")
                                
                                // ƒê√°nh d·∫•u session th·∫•t b·∫°i
                                sessionBackup.markSessionFailed(customerId, "SMS kh√¥ng ƒë·∫øn ƒë∆∞·ª£c ng∆∞·ªùi nh·∫≠n")
                                
                                // G·ª≠i broadcast c·∫≠p nh·∫≠t ti·∫øn ƒë·ªô
                                sendProgressBroadcast(
                                    totalSent,
                                    totalToSend,
                                    "‚ùå SMS kh√¥ng ƒë·∫øn ƒë∆∞·ª£c ng∆∞·ªùi nh·∫≠n (requestId: $requestId)"
                                )
                            }
                            else -> {
                                Log.w(TAG, "‚ö†Ô∏è SMS delivery result unknown (resultCode: $resultCode, requestId: $requestId)")
                                
                                // N·∫øu kh√¥ng r√µ k·∫øt qu·∫£, v·∫´n x√≥a kh√°ch h√†ng ƒë·ªÉ tr√°nh tr∆∞·ªùng h·ª£p treo
                                val customer = pendingSmsDeliveries.remove(requestId)
                                if (customer != null) {
                                    // ƒê√°nh d·∫•u kh√°ch h√†ng ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω nh∆∞ng kh√¥ng x√≥a
                                    sessionBackup.markCustomerProcessed(customer.id)
                                    
                                    // G·ª≠i broadcast c·∫≠p nh·∫≠t ti·∫øn ƒë·ªô
                                    sendProgressBroadcast(
                                        totalSent,
                                        totalToSend,
                                        "‚ö†Ô∏è Kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c k·∫øt qu·∫£ g·ª≠i ƒë·∫øn ${customer.name}"
                                    )
                                }
                            }
                        }
                    }
                }
            }
        }
        
        val filter = IntentFilter().apply {
            addAction(SMS_DELIVERED_ACTION)
        }
        
        try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                registerReceiver(smsDeliveryReceiver, filter, Context.RECEIVER_NOT_EXPORTED)
            } else {
                registerReceiver(smsDeliveryReceiver, filter)
            }
            Log.d(TAG, "‚úÖ SMS delivery receiver registered successfully")
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Failed to register SMS delivery receiver", e)
        }
    }
    
    private fun broadcastCustomerDeleted(customerId: String) {
        val intent = Intent(ACTION_CUSTOMER_DELETED).apply {
            putExtra(EXTRA_CUSTOMER_ID, customerId)
        }
        sendBroadcast(intent)
    }

    /**
     * Ki·ªÉm tra c√°c c√†i ƒë·∫∑t thi·∫øt b·ªã c√≥ th·ªÉ ·∫£nh h∆∞·ªüng ƒë·∫øn vi·ªác g·ª≠i SMS
     */
    private fun checkDeviceSettings(): String {
        val issues = mutableListOf<String>()

        try {
            // Ki·ªÉm tra quy·ªÅn SMS
            if (!SmsUtils.hasRequiredPermissions(this)) {
                issues.add("‚ùå Thi·∫øu quy·ªÅn SMS")
            }

            // Ki·ªÉm tra tr·∫°ng th√°i m·∫°ng
            val telephonyManager = getSystemService(Context.TELEPHONY_SERVICE) as TelephonyManager
            val networkState = telephonyManager.networkType
            if (networkState == TelephonyManager.NETWORK_TYPE_UNKNOWN) {
                issues.add("‚ö†Ô∏è Kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c lo·∫°i m·∫°ng")
            }

            // Ki·ªÉm tra SIM card
            val simState = telephonyManager.simState
            when (simState) {
                TelephonyManager.SIM_STATE_ABSENT -> issues.add("‚ùå Kh√¥ng c√≥ SIM card")
                TelephonyManager.SIM_STATE_NETWORK_LOCKED -> issues.add("‚ùå SIM b·ªã kh√≥a m·∫°ng")
                TelephonyManager.SIM_STATE_PIN_REQUIRED -> issues.add("‚ùå SIM y√™u c·∫ßu PIN")
                TelephonyManager.SIM_STATE_PUK_REQUIRED -> issues.add("‚ùå SIM y√™u c·∫ßu PUK")
                TelephonyManager.SIM_STATE_UNKNOWN -> issues.add("‚ö†Ô∏è Tr·∫°ng th√°i SIM kh√¥ng x√°c ƒë·ªãnh")
                TelephonyManager.SIM_STATE_READY -> Log.d(TAG, "‚úÖ SIM card s·∫µn s√†ng")
            }

            // Ki·ªÉm tra airplane mode
            val airplaneMode = android.provider.Settings.Global.getInt(
                contentResolver,
                android.provider.Settings.Global.AIRPLANE_MODE_ON,
                0
            ) != 0
            if (airplaneMode) {
                issues.add("‚ùå Ch·∫ø ƒë·ªô m√°y bay ƒëang b·∫≠t")
            }

            // Ki·ªÉm tra SmsManager
            try {
                val smsManager = SmsManager.getDefault()
                Log.d(TAG, "‚úÖ SmsManager kh·∫£ d·ª•ng")
            } catch (e: Exception) {
                issues.add("‚ùå Kh√¥ng th·ªÉ truy c·∫≠p SmsManager: ${e.message}")
            }

        } catch (e: Exception) {
            issues.add("‚ùå L·ªói ki·ªÉm tra thi·∫øt b·ªã: ${e.message}")
            Log.e(TAG, "Error checking device settings", e)
        }

        return if (issues.isEmpty()) {
            "‚úÖ Thi·∫øt b·ªã s·∫µn s√†ng g·ª≠i SMS"
        } else {
            "Ph√°t hi·ªán v·∫•n ƒë·ªÅ:\n${issues.joinToString("\n")}"
        }
    }

    /**
     * X√≥a kh√°ch h√†ng sau khi g·ª≠i SMS th√†nh c√¥ng v√† g·ª≠i broadcast th√¥ng b√°o
     */
    private fun deleteCustomerAfterSuccessfulSend(customer: Customer) {
        Log.d(TAG, "üóëÔ∏è B·∫Øt ƒë·∫ßu x√≥a kh√°ch h√†ng ${customer.name} (ID: ${customer.id})")
        
        // ƒê√°nh d·∫•u kh√°ch h√†ng ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω trong session backup tr∆∞·ªõc khi x√≥a
        sessionBackup.markCustomerProcessed(customer.id)
        
        // L·∫•y danh s√°ch kh√°ch h√†ng hi·ªán t·∫°i
        val currentCustomers = smsRepository.getCustomers()
        
        // Ki·ªÉm tra xem kh√°ch h√†ng c√≥ t·ªìn t·∫°i trong danh s√°ch kh√¥ng
        val customerExists = currentCustomers.any { it.id == customer.id }
        if (!customerExists) {
            Log.w(TAG, "‚ö†Ô∏è Kh√°ch h√†ng ${customer.id} kh√¥ng t·ªìn t·∫°i trong danh s√°ch")
            return
        }
        
        // L·ªçc kh√°ch h√†ng ra kh·ªèi danh s√°ch
        val updatedCustomers = currentCustomers.filter { it.id != customer.id }
        
        // L∆∞u danh s√°ch m·ªõi
        smsRepository.saveCustomers(updatedCustomers)
        Log.d(TAG, "üíæ ƒê√£ l∆∞u danh s√°ch kh√°ch h√†ng m·ªõi (ƒë√£ x√≥a ${customer.id})")
        
        // Ki·ªÉm tra l·∫°i xem kh√°ch h√†ng ƒë√£ th·ª±c s·ª± b·ªã x√≥a ch∆∞a
        val checkCustomers = smsRepository.getCustomers()
        val stillExists = checkCustomers.any { it.id == customer.id }
        
        if (stillExists) {
            Log.e(TAG, "‚ùå Kh√°ch h√†ng ${customer.id} v·∫´n c√≤n t·ªìn t·∫°i sau khi x√≥a!")
        } else {
            Log.d(TAG, "‚úÖ ƒê√£ x√≥a th√†nh c√¥ng kh√°ch h√†ng ${customer.id}")
            
            // G·ª≠i broadcast th√¥ng b√°o ƒë√£ x√≥a kh√°ch h√†ng
            val intent = Intent(ACTION_CUSTOMER_DELETED).apply {
                putExtra(EXTRA_CUSTOMER_ID, customer.id)
            }
            sendBroadcast(intent)
            Log.d(TAG, "üì¢ ƒê√£ g·ª≠i broadcast x√≥a kh√°ch h√†ng v·ªõi ID: ${customer.id}")
            
            // ƒê·∫£m b·∫£o broadcast ƒë∆∞·ª£c g·ª≠i b·∫±ng c√°ch g·ª≠i th√™m m·ªôt l·∫ßn n·ªØa sau m·ªôt kho·∫£ng th·ªùi gian ng·∫Øn
            Handler(Looper.getMainLooper()).postDelayed({
                val retryIntent = Intent(ACTION_CUSTOMER_DELETED).apply {
                    putExtra(EXTRA_CUSTOMER_ID, customer.id)
                }
                sendBroadcast(retryIntent)
                Log.d(TAG, "üì¢ G·ª≠i l·∫°i broadcast x√≥a kh√°ch h√†ng v·ªõi ID: ${customer.id}")
            }, 500)
        }
    }
} 