package com.example.sms_app.utils

import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.net.Uri
import android.os.Build
import android.provider.Settings
import android.widget.Toast
import androidx.annotation.Keep
import androidx.core.content.FileProvider
import com.example.sms_app.api.UpdateApiService
import com.example.sms_app.api.VersionResponse
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import okhttp3.OkHttpClient
import okhttp3.logging.HttpLoggingInterceptor
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import timber.log.Timber
import java.io.File
import java.io.FileOutputStream
import java.io.InputStream
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class AppUpdateManager @Inject constructor(
    private val context: Context
) {
    companion object {
        private const val BASE_URL = "http://42.96.16.211:6868/"
        private const val CURRENT_VERSION = "1.0.0"
        private const val CURRENT_VERSION_CODE = 1
        private const val TIMEOUT_SECONDS = 10L
    }

    private val apiService: UpdateApiService by lazy {
        val loggingInterceptor = HttpLoggingInterceptor().apply {
            level = HttpLoggingInterceptor.Level.BODY
        }

        val okHttpClient = OkHttpClient.Builder()
            .addInterceptor(loggingInterceptor)
            .build()

        Retrofit.Builder()
            .baseUrl(BASE_URL)
            .client(okHttpClient)
            .addConverterFactory(GsonConverterFactory.create())
            .build()
            .create(UpdateApiService::class.java)
    }
    
    @Keep
    data class UpdateInfo(
        val versionCode: Int = 0,
        val versionName: String = "",
        val downloadUrl: String = "",
        val releaseNotes: String = "",
        val forceUpdate: Boolean = false,
        val minSupportedVersion: Int = 0,
        val fileSize: Long = 0
    )
    
    suspend fun checkForUpdates(): UpdateInfo? {
        return try {
            Timber.d("üîç Checking for updates from API...")
            Toast.makeText(context, "ƒêang ki·ªÉm tra c·∫≠p nh·∫≠t...", Toast.LENGTH_SHORT).show()

            // Call API ƒë·ªÉ l·∫•y version m·ªõi nh·∫•t
            val response = apiService.getLatestVersion()

            if (response.isSuccessful) {
                val versionResponse = response.body()
                Timber.d("üìä API response: $versionResponse")

                if (versionResponse != null) {
                    val currentVersionCode = CURRENT_VERSION_CODE
                    val currentVersionName = CURRENT_VERSION

                    Timber.d("üì± Current version: $currentVersionName ($currentVersionCode)")
                    Timber.d("üÜï Latest version: ${versionResponse.version} (${versionResponse.versionCode})")

                    val isVersionNewer = isNewerVersion(versionResponse.version, currentVersionName)
                    val isVersionCodeNewer = versionResponse.versionCode > currentVersionCode
                    Timber.d("üîç Version comparison details:")
                    Timber.d("   Server version: ${versionResponse.version} (code: ${versionResponse.versionCode})")
                    Timber.d("   Current version: $currentVersionName (code: $currentVersionCode)")
                    Timber.d("   Version string newer: $isVersionNewer")
                    Timber.d("   Version code newer: $isVersionCodeNewer")
                    Timber.d("   Final result: ${isVersionNewer || isVersionCodeNewer}")

                    if (isVersionNewer || isVersionCodeNewer) {
                        Timber.d("‚úÖ Update available!")
                        Toast.makeText(context, "üöÄ C√≥ c·∫≠p nh·∫≠t m·ªõi v${versionResponse.version}!", Toast.LENGTH_SHORT).show()

                        // Convert VersionResponse to UpdateInfo
                        return UpdateInfo(
                            versionCode = versionResponse.versionCode,
                            versionName = versionResponse.version,
                            downloadUrl = BASE_URL + "download",
                            releaseNotes = versionResponse.releaseNotes.ifEmpty {
                                "üöÄ C·∫≠p nh·∫≠t m·ªõi v${versionResponse.version}\n\n‚úÖ C·∫£i thi·ªán hi·ªáu su·∫•t\n‚úÖ S·ª≠a l·ªói v√† t·ªëi ∆∞u h√≥a"
                            },
                            forceUpdate = versionResponse.forceUpdate,
                            minSupportedVersion = currentVersionCode,
                            fileSize = versionResponse.fileSize
                        )
                    } else {
                        Timber.d("‚úÖ App is up to date")
                        Toast.makeText(context, "‚úÖ ƒê√£ s·ª≠ d·ª•ng phi√™n b·∫£n m·ªõi nh·∫•t", Toast.LENGTH_SHORT).show()
                    }
                } else {
                    Timber.w("‚ùå API response body is null")
                    Toast.makeText(context, "‚ùå Kh√¥ng nh·∫≠n ƒë∆∞·ª£c d·ªØ li·ªáu t·ª´ server", Toast.LENGTH_SHORT).show()
                }
            } else if (response.code() == 404) {
                // 404 c√≥ nghƒ©a l√† kh√¥ng c√≥ version info - t·ª©c l√† kh√¥ng c√≥ update
                Timber.d("‚úÖ No update available (404 response)")
                Toast.makeText(context, "‚úÖ ƒê√£ s·ª≠ d·ª•ng phi√™n b·∫£n m·ªõi nh·∫•t", Toast.LENGTH_SHORT).show()
            } else {
                Timber.w("‚ùå API call failed: ${response.code()} - ${response.message()}")
                Toast.makeText(context, "‚ùå L·ªói server: ${response.code()}", Toast.LENGTH_SHORT).show()
            }
            null
        } catch (e: Exception) {
            Timber.e(e, "‚ùå Error checking for updates")
            // App v·∫´n ch·∫°y b√¨nh th∆∞·ªùng khi API l·ªói - ch·ªâ log v√† hi·ªÉn th·ªã toast ng·∫Øn
            when {
                e.message?.contains("CLEARTEXT communication", ignoreCase = true) == true -> {
                    Toast.makeText(context, "üîí L·ªói b·∫£o m·∫≠t m·∫°ng - vui l√≤ng th·ª≠ l·∫°i", Toast.LENGTH_SHORT).show()
                }
                e.message?.contains("timeout", ignoreCase = true) == true -> {
                    Toast.makeText(context, "‚è∞ Timeout khi ki·ªÉm tra c·∫≠p nh·∫≠t", Toast.LENGTH_SHORT).show()
                }
                e.message?.contains("network", ignoreCase = true) == true ||
                e.message?.contains("connection", ignoreCase = true) == true ||
                e.message?.contains("UnknownServiceException", ignoreCase = true) == true -> {
                    Toast.makeText(context, "üì∂ Kh√¥ng th·ªÉ k·∫øt n·ªëi server c·∫≠p nh·∫≠t", Toast.LENGTH_SHORT).show()
                }
                else -> {
                    Toast.makeText(context, "‚ö†Ô∏è Kh√¥ng th·ªÉ ki·ªÉm tra c·∫≠p nh·∫≠t", Toast.LENGTH_SHORT).show()
                }
            }
            // Tr·∫£ v·ªÅ null ƒë·ªÉ app ti·∫øp t·ª•c ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng
            null
        }
    }
    
    suspend fun downloadAndInstallUpdate(
        updateInfo: UpdateInfo,
        onProgress: (Float) -> Unit = {}
    ): Boolean {
        return try {
            val apkFile = File(context.getExternalFilesDir(null), "update.apk")

            // X√≥a file c≈© n·∫øu c√≥
            if (apkFile.exists()) {
                apkFile.delete()
            }

            Toast.makeText(context, "B·∫Øt ƒë·∫ßu t·∫£i xu·ªëng c·∫≠p nh·∫≠t...", Toast.LENGTH_SHORT).show()
            Timber.d("üöÄ Starting download from: ${updateInfo.downloadUrl}")

            // Download APK t·ª´ API
            val response = apiService.downloadApk()

            if (response.isSuccessful) {
                val body = response.body()
                if (body != null) {
                    withContext(Dispatchers.IO) {
                        val inputStream: InputStream = body.byteStream()
                        val outputStream = FileOutputStream(apkFile)

                        val totalBytes = body.contentLength()
                        var downloadedBytes = 0L
                        val buffer = ByteArray(8192)
                        var bytesRead: Int

                        while (inputStream.read(buffer).also { bytesRead = it } != -1) {
                            outputStream.write(buffer, 0, bytesRead)
                            downloadedBytes += bytesRead

                            // Update progress
                            if (totalBytes > 0) {
                                val progress = downloadedBytes.toFloat() / totalBytes.toFloat()
                                onProgress(progress)
                                Timber.d("üì• Download progress: ${(progress * 100).toInt()}%")
                            }
                        }

                        outputStream.close()
                        inputStream.close()
                    }

                    Toast.makeText(context, "‚úÖ T·∫£i xu·ªëng ho√†n th√†nh! ƒêang m·ªü tr√¨nh c√†i ƒë·∫∑t...", Toast.LENGTH_SHORT).show()
                    Timber.d("‚úÖ Download completed: ${apkFile.absolutePath}")

                    // Install APK - tr·∫£ v·ªÅ false v√¨ qu√° tr√¨nh c√†i ƒë·∫∑t s·∫Ω ƒë∆∞·ª£c x·ª≠ l√Ω b·ªüi system
                    installApk(apkFile)
                    false // Kh√¥ng tr·∫£ v·ªÅ true v√¨ c√†i ƒë·∫∑t ch∆∞a ho√†n th√†nh
                } else {
                    Timber.e("‚ùå Download response body is null")
                    Toast.makeText(context, "‚ùå L·ªói t·∫£i xu·ªëng: Kh√¥ng nh·∫≠n ƒë∆∞·ª£c d·ªØ li·ªáu", Toast.LENGTH_LONG).show()
                    false
                }
            } else {
                Timber.e("‚ùå Download failed: ${response.code()} - ${response.message()}")
                Toast.makeText(context, "‚ùå L·ªói t·∫£i xu·ªëng: ${response.code()}", Toast.LENGTH_LONG).show()
                false
            }
        } catch (e: Exception) {
            Timber.e(e, "‚ùå Error downloading update")
            when {
                e.message?.contains("timeout", ignoreCase = true) == true -> {
                    Toast.makeText(context, "‚è∞ Timeout khi t·∫£i xu·ªëng", Toast.LENGTH_LONG).show()
                }
                e.message?.contains("network", ignoreCase = true) == true -> {
                    Toast.makeText(context, "üì∂ L·ªói k·∫øt n·ªëi khi t·∫£i xu·ªëng", Toast.LENGTH_LONG).show()
                }
                else -> {
                    Toast.makeText(context, "‚ùå L·ªói t·∫£i xu·ªëng: ${e.message}", Toast.LENGTH_LONG).show()
                }
            }
            false
        }
    }
    
    private fun installApk(apkFile: File) {
        try {
            Timber.d("üîß Starting APK installation: ${apkFile.absolutePath}")

            // Ki·ªÉm tra file t·ªìn t·∫°i
            if (!apkFile.exists()) {
                Timber.e("‚ùå APK file does not exist: ${apkFile.absolutePath}")
                Toast.makeText(context, "‚ùå File APK kh√¥ng t·ªìn t·∫°i", Toast.LENGTH_LONG).show()
                return
            }

            // Ki·ªÉm tra permission c√†i ƒë·∫∑t
            if (!canInstallApk()) {
                Timber.w("‚ö†Ô∏è No permission to install APK")
                Toast.makeText(context, "‚ö†Ô∏è C·∫ßn c·∫•p quy·ªÅn c√†i ƒë·∫∑t ·ª©ng d·ª•ng", Toast.LENGTH_LONG).show()
                requestInstallPermission()
                return
            }

            val uri = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
                FileProvider.getUriForFile(
                    context,
                    "${context.packageName}.fileprovider",
                    apkFile
                )
            } else {
                Uri.fromFile(apkFile)
            }

            Timber.d("üîß APK URI: $uri")

            val intent = Intent(Intent.ACTION_VIEW).apply {
                setDataAndType(uri, "application/vnd.android.package-archive")
                addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
            }

            // Log th√¥ng tin APK ƒë·ªÉ debug
            Timber.d("üîç APK info:")
            Timber.d("   File size: ${apkFile.length()} bytes")
            Timber.d("   File path: ${apkFile.absolutePath}")
            Timber.d("   Current app version: ${getCurrentVersionName()} (${getCurrentVersionCode()})")

            // Th√™m th√¥ng tin chi ti·∫øt v·ªÅ APK
            try {
                val packageManager = context.packageManager
                val packageInfo = packageManager.getPackageArchiveInfo(apkFile.absolutePath, 0)
                if (packageInfo != null) {
                    Timber.d("üîç Downloaded APK info:")
                    Timber.d("   Package name: ${packageInfo.packageName}")
                    Timber.d("   Version name: ${packageInfo.versionName}")
                    Timber.d("   Version code: ${if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) packageInfo.longVersionCode else packageInfo.versionCode}")
                } else {
                    Timber.e("‚ùå Cannot read APK package info - file may be corrupted")
                    Toast.makeText(context, "‚ùå File APK b·ªã l·ªói", Toast.LENGTH_LONG).show()
                    return
                }
            } catch (e: Exception) {
                Timber.e(e, "‚ùå Error reading APK info")
                Toast.makeText(context, "‚ùå Kh√¥ng th·ªÉ ƒë·ªçc th√¥ng tin APK", Toast.LENGTH_LONG).show()
                return
            }

            // Th·ª≠ c√†i ƒë·∫∑t v·ªõi method ch√≠nh
            val packageManager = context.packageManager
            if (intent.resolveActivity(packageManager) != null) {
                Timber.d("‚úÖ Starting install activity with FileProvider")
                context.startActivity(intent)
                Toast.makeText(context, "üì± ƒêang m·ªü tr√¨nh c√†i ƒë·∫∑t...", Toast.LENGTH_SHORT).show()
            } else {
                // Fallback: Th·ª≠ v·ªõi Uri.fromFile cho Android c≈©
                Timber.w("‚ö†Ô∏è FileProvider method failed, trying fallback...")
                try {
                    val fallbackIntent = Intent(Intent.ACTION_VIEW).apply {
                        setDataAndType(Uri.fromFile(apkFile), "application/vnd.android.package-archive")
                        addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                    }

                    if (fallbackIntent.resolveActivity(packageManager) != null) {
                        Timber.d("‚úÖ Starting install with fallback method")
                        context.startActivity(fallbackIntent)
                        Toast.makeText(context, "üì± ƒêang m·ªü tr√¨nh c√†i ƒë·∫∑t (fallback)...", Toast.LENGTH_SHORT).show()
                    } else {
                        Timber.e("‚ùå No activity found to handle install intent")
                        Toast.makeText(context, "‚ùå Kh√¥ng t√¨m th·∫•y tr√¨nh c√†i ƒë·∫∑t", Toast.LENGTH_LONG).show()
                    }
                } catch (e: Exception) {
                    Timber.e(e, "‚ùå Fallback install method failed")
                    Toast.makeText(context, "‚ùå Kh√¥ng th·ªÉ m·ªü tr√¨nh c√†i ƒë·∫∑t", Toast.LENGTH_LONG).show()
                }
            }

        } catch (e: Exception) {
            Timber.e(e, "‚ùå Error installing APK")
            Toast.makeText(context, "‚ùå L·ªói c√†i ƒë·∫∑t: ${e.message}", Toast.LENGTH_LONG).show()

            // G·ª£i √Ω uninstall v√† c√†i l·∫°i
            Toast.makeText(context, "üí° Th·ª≠ g·ª° c√†i ƒë·∫∑t app c≈© v√† c√†i l·∫°i", Toast.LENGTH_LONG).show()
        }
    }

    /**
     * M·ªü settings ƒë·ªÉ uninstall app hi·ªán t·∫°i
     */
    fun openUninstallSettings() {
        try {
            val intent = Intent(Intent.ACTION_DELETE).apply {
                data = Uri.parse("package:${context.packageName}")
                addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            }
            context.startActivity(intent)
            Toast.makeText(context, "üì± G·ª° c√†i ƒë·∫∑t app c≈©, sau ƒë√≥ c√†i l·∫°i APK m·ªõi", Toast.LENGTH_LONG).show()
        } catch (e: Exception) {
            Timber.e(e, "‚ùå Error opening uninstall settings")
            Toast.makeText(context, "‚ùå Kh√¥ng th·ªÉ m·ªü c√†i ƒë·∫∑t g·ª° c√†i ƒë·∫∑t", Toast.LENGTH_LONG).show()
        }
    }
    
    private fun getCurrentVersionCode(): Int {
        return try {
            val packageInfo = context.packageManager.getPackageInfo(context.packageName, 0)
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
                packageInfo.longVersionCode.toInt()
            } else {
                @Suppress("DEPRECATION")
                packageInfo.versionCode
            }
        } catch (e: PackageManager.NameNotFoundException) {
            Timber.e(e, "Could not get version code")
            0
        }
    }
    
    fun getCurrentVersionName(): String {
        return try {
            val packageInfo = context.packageManager.getPackageInfo(context.packageName, 0)
            packageInfo.versionName ?: "Unknown"
        } catch (e: PackageManager.NameNotFoundException) {
            Timber.e(e, "Could not get version name")
            "Unknown"
        }
    }

    /**
     * Ki·ªÉm tra xem app c√≥ th·ªÉ c√†i ƒë·∫∑t APK kh√¥ng
     */
    fun canInstallApk(): Boolean {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            context.packageManager.canRequestPackageInstalls()
        } else {
            true
        }
    }

    /**
     * Y√™u c·∫ßu permission c√†i ƒë·∫∑t APK
     */
    private fun requestInstallPermission() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            try {
                val intent = Intent(Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES).apply {
                    data = Uri.parse("package:${context.packageName}")
                    addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                }
                context.startActivity(intent)
                Toast.makeText(context, "üì± Vui l√≤ng b·∫≠t 'Cho ph√©p t·ª´ ngu·ªìn n√†y' v√† th·ª≠ l·∫°i", Toast.LENGTH_LONG).show()
            } catch (e: Exception) {
                Timber.e(e, "‚ùå Error requesting install permission")
                Toast.makeText(context, "‚ùå Kh√¥ng th·ªÉ m·ªü c√†i ƒë·∫∑t quy·ªÅn", Toast.LENGTH_LONG).show()
            }
        }
    }

    /**
     * M·ªü settings ƒë·ªÉ cho ph√©p c√†i ƒë·∫∑t APK
     */
    fun openInstallPermissionSettings() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val intent = Intent(Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES).apply {
                data = Uri.parse("package:${context.packageName}")
                addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            }
            context.startActivity(intent)
        }
    }

    /**
     * Test API connection
     */
    suspend fun testApiConnection(): Boolean {
        return try {
            Timber.d("üß™ Testing API connection...")
            Toast.makeText(context, "üß™ Testing API...", Toast.LENGTH_SHORT).show()

            // Test API version endpoint
            val response = apiService.getLatestVersion()

            if (response.isSuccessful) {
                val versionResponse = response.body()
                Timber.d("üîó API connected successfully")
                Timber.d("üìä Version data: $versionResponse")

                Toast.makeText(context, "‚úÖ API OK! Version: ${versionResponse?.version ?: "Unknown"}", Toast.LENGTH_LONG).show()
                true
            } else {
                Timber.w("‚ùå API test failed: ${response.code()} - ${response.message()}")
                Toast.makeText(context, "‚ùå API Error: ${response.code()}", Toast.LENGTH_LONG).show()
                false
            }
        } catch (e: Exception) {
            Timber.e(e, "‚ùå API test failed")
            Toast.makeText(context, "‚ùå API test error: ${e.message}", Toast.LENGTH_LONG).show()
            false
        }
    }

    /**
     * So s√°nh version string ƒë·ªÉ xem version m·ªõi c√≥ cao h∆°n version hi·ªán t·∫°i kh√¥ng
     * V√≠ d·ª•: "1.0.1" > "1.0.0" = true
     */
    private fun isNewerVersion(newVersion: String, currentVersion: String): Boolean {
        try {
            val newParts = newVersion.split(".").map { it.toIntOrNull() ?: 0 }
            val currentParts = currentVersion.split(".").map { it.toIntOrNull() ?: 0 }

            val maxLength = maxOf(newParts.size, currentParts.size)

            for (i in 0 until maxLength) {
                val newPart = newParts.getOrNull(i) ?: 0
                val currentPart = currentParts.getOrNull(i) ?: 0

                when {
                    newPart > currentPart -> {
                        Timber.d("üîç Version comparison: $newVersion > $currentVersion (part $i: $newPart > $currentPart)")
                        return true
                    }
                    newPart < currentPart -> {
                        Timber.d("üîç Version comparison: $newVersion < $currentVersion (part $i: $newPart < $currentPart)")
                        return false
                    }
                    // newPart == currentPart, continue to next part
                }
            }

            Timber.d("üîç Version comparison: $newVersion == $currentVersion")
            return false
        } catch (e: Exception) {
            Timber.e(e, "‚ùå Error comparing versions: $newVersion vs $currentVersion")
            return false
        }
    }
}
